<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.backend.be.mapper.SpatialTableMapper">

    <!-- 获取所有表名 -->
    <select id="getAllTableNames" resultType="java.lang.String">
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_type = 'BASE TABLE'
        ORDER BY table_name
    </select>

    <!-- 检查表是否存在 -->
    <select id="tableExists" resultType="boolean">
        SELECT EXISTS (
            SELECT 1 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = #{tableName}
        )
    </select>

    <!-- 获取表数据 -->
    <select id="getTableData" resultType="java.util.Map">
        SELECT * FROM ${tableName} LIMIT 100
    </select>

    <!-- 获取表结构 -->
    <select id="getTableSchema" resultType="java.util.Map">
        SELECT 
            column_name,
            data_type,
            is_nullable,
            column_default
        FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = #{tableName}
        ORDER BY ordinal_position
    </select>

    <!-- 获取空间表列表 -->
    <select id="getSpatialTables" resultType="java.lang.String">
        SELECT f_table_name 
        FROM geometry_columns 
        WHERE f_table_schema = 'public'
        ORDER BY f_table_name
    </select>

    <!-- 获取单个空间表的GeoJSON数据 -->
    <select id="getSpatialTableGeojson" resultType="java.lang.String">
        SELECT json_build_object(
            'type', 'FeatureCollection',
            'features', COALESCE(json_agg(
                json_build_object(
                    'type', 'Feature',
                    'geometry', ST_AsGeoJSON(
                        CASE 
                            WHEN #{tableName} = 'map_elements' THEN element_location
                            ELSE geom
                        END
                    )::json,
                    'properties', to_jsonb(t.*) - 
                        CASE 
                            WHEN #{tableName} = 'map_elements' THEN 'element_location'::text
                            ELSE 'geom'::text
                        END
                )
            ), '[]'::json)
        )::text
        FROM ${tableName} t
    </select>

    <!-- 获取多个空间表的GeoJSON数据 -->
    <select id="getSpatialTablesGeojson" resultType="java.lang.String">
        SELECT json_build_object(
            'type', 'FeatureCollection',
            'features', COALESCE(json_agg(
                json_build_object(
                    'type', 'Feature',
                    'geometry', ST_AsGeoJSON(
                        CASE 
                            WHEN table_name = 'map_elements' THEN element_location
                            ELSE geom
                        END
                    )::json,
                    'properties', to_jsonb(t.*) - 
                        CASE 
                            WHEN table_name = 'map_elements' THEN 'element_location'::text
                            ELSE 'geom'::text
                        END
                )
            ), '[]'::json)
        )::text
        FROM (
        <foreach collection="tableNames" item="tableName" separator=" UNION ALL ">
                SELECT *, '${tableName}' as table_name FROM ${tableName}
        </foreach>
        ) t
    </select>

    <!-- 根据坐标范围查询空间表要素并返回GeoJSON -->
    <select id="getSpatialTableGeojsonByExtent" resultType="java.lang.String">
        SELECT json_build_object(
            'type', 'FeatureCollection',
            'features', COALESCE(json_agg(
                json_build_object(
                    'type', 'Feature',
                    'geometry', ST_AsGeoJSON(
                        CASE 
                            WHEN #{tableName} = 'map_elements' THEN element_location
                            ELSE geom
                        END
                    )::json,
                    'properties', to_jsonb(t.*) - 
                        CASE 
                            WHEN #{tableName} = 'map_elements' THEN 'element_location'::text
                            ELSE 'geom'::text
                        END
                )
            ), '[]'::json)
        )::text
        FROM ${tableName} t
        WHERE ST_Intersects(
            CASE 
                WHEN #{tableName} = 'map_elements' THEN element_location
                ELSE geom
            END,
            ST_MakeEnvelope(#{minX}, #{minY}, #{maxX}, #{maxY}, 4326)
        )
    </select>


    <select id="getSpatialTableGeojsonByFields" parameterType="com.backend.be.model.FieldQueryRequest" resultType="string">
        <!-- 动态检测几何字段 -->
        <choose>
            <!-- 对于map_elements表，使用element_location字段 -->
            <when test="tableName == 'map_elements'">
            SELECT jsonb_build_object(
                'type', 'FeatureCollection',
                'features', jsonb_agg(
                    jsonb_build_object(
                        'type', 'Feature',
                        'geometry', ST_AsGeoJSON(ST_Transform(element_location, 4326))::jsonb,
                        'properties', to_jsonb(sub) - 'element_location'
                    )
                )
            ) AS geojson
            FROM (
                SELECT * 
                FROM ${tableName}
                WHERE 1=1
                <foreach collection="fieldConditions.entrySet()" item="value" index="key" separator=" AND ">
                    <choose>
                        <!-- 处理几何字段的空间查询 -->
                        <when test="key == 'geom' or key == 'element_location'">
                            <choose>
                                <when test="value == null">
                                    ${key} IS NULL
                                </when>
                                <when test="value.startsWith('POINT') or value.startsWith('POLYGON') or value.startsWith('MULTIPOLYGON') or value.startsWith('LINESTRING') or value.startsWith('MULTILINESTRING')">
                                    AND ST_Intersects(ST_Transform(${key}, 4326), ST_GeomFromText(#{value}, 4326))
                                </when>
                                <otherwise>
                                    ${key} = #{value}
                                </otherwise>
                            </choose>
                        </when>
                        <!-- 处理普通字段 -->
                        <when test="value == null">
                            ${key} IS NULL
                        </when>
                        <otherwise>
                            ${key} = #{value}
                        </otherwise>
                    </choose>
                </foreach>
            ) AS sub
            </when>
            <!-- 对于其他表，默认使用geom字段 -->
            <otherwise>
            SELECT jsonb_build_object(
                'type', 'FeatureCollection',
                'features', jsonb_agg(
                    jsonb_build_object(
                        'type', 'Feature',
                        'geometry', ST_AsGeoJSON(ST_Transform(geom, 4326))::jsonb,
                        'properties', to_jsonb(sub) - 'geom'
                    )
                )
            ) AS geojson
            FROM (
                SELECT * 
                FROM ${tableName}
                WHERE 1=1
                <foreach collection="fieldConditions.entrySet()" item="value" index="key" separator=" AND ">
                    <choose>
                        <!-- 处理几何字段的空间查询 -->
                        <when test="key == 'geom' or key == 'element_location'">
                            <choose>
                                <when test="value == null">
                                    ${key} IS NULL
                                </when>
                                <when test="value.startsWith('POINT') or value.startsWith('POLYGON') or value.startsWith('MULTIPOLYGON') or value.startsWith('LINESTRING') or value.startsWith('MULTILINESTRING')">
                                    AND ST_Intersects(ST_Transform(${key}, 4326), ST_GeomFromText(#{value}, 4326))
                                </when>
                                <otherwise>
                                    ${key} = #{value}
                                </otherwise>
                            </choose>
                        </when>
                        <!-- 处理普通字段 -->
                        <when test="value == null">
                            ${key} IS NULL
                        </when>
                        <otherwise>
                            ${key} = #{value}
                        </otherwise>
                    </choose>
                </foreach>
            ) AS sub
            </otherwise>
        </choose>
    </select>

</mapper>
